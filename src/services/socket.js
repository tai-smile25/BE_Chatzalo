const socketIO = require('socket.io');
const jwt = require('jsonwebtoken');
const User = require('../models/user.model');
const Group = require('../models/group.model');
const { v4: uuidv4 } = require('uuid');

let io;
const userSockets = new Map(); // L∆∞u tr·ªØ socket connections c·ªßa users
const groupRooms = new Map(); // Th√™m bi·∫øn ƒë·ªÉ l∆∞u tr·ªØ c√°c ph√≤ng chat nh√≥m
const onlineUsers = new Map();

const initializeSocket = (server) => {
    io = socketIO(server, {
        cors: {
            origin: '*',
            
            methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'HEAD'],
            allowedHeaders: ['Content-Type', 'Authorization', 'Accept', 'X-Requested-With', '*'],
            // credentials: true,
            preflightContinue: false,
            optionsSuccessStatus: 204
        },
        transports: ['polling', 'websocket'],
        allowUpgrades: true,
        pingTimeout: 60000,
        pingInterval: 25000,
        cookie: false,
        allowEIO3: true,
        path: '/socket.io/',
        serveClient: true,
        connectTimeout: 45000,
        maxHttpBufferSize: 1e8,
        cors: true
    });

    // Log khi server socket kh·ªüi ƒë·ªông
    console.log('Socket.IO server initialized');

    // Middleware x√°c th·ª±c token
    io.use((socket, next) => {
        const token = socket.handshake.auth.token;
        console.log('Socket auth attempt with token:', token ? 'exists' : 'not found');
        
        if (!token) {
            console.error('Socket auth error: No token provided');
            return next(new Error('Authentication error'));
        }

        try {
            const decoded = jwt.verify(token, process.env.JWT_SECRET);
            socket.user = decoded;
            console.log('Socket authenticated for user:', decoded.email);
            next();
        } catch (error) {
            console.error('Socket auth error:', error.message);
            return next(new Error('Authentication error'));
        }
    });

    io.on('connection', (socket) => {
        const userEmail = socket.user.email;
        console.log('New client connected:', userEmail);

        // L∆∞u socket connection c·ªßa user
        if (!userSockets.has(userEmail)) {
            userSockets.set(userEmail, new Set());
        }
        userSockets.get(userEmail).add(socket.id);

        socket.on("register", (userId) => {
            socket.userId = userId;
            onlineUsers[userId] = socket.id;
            console.log(`User ${userId} connected with socket ${socket.id}`);
        });

        // X·ª≠ l√Ω s·ª± ki·ªán tham gia nh√≥m chat
        socket.on('joinGroup', async (data) => {
            try {
                const { groupId } = data;
                console.log('User joining group:', userEmail, 'groupId:', groupId);
                
                // Tham gia v√†o ph√≤ng socket c·ªßa nh√≥m
                socket.join(groupId);
                
                // L∆∞u th√¥ng tin ph√≤ng
                if (!groupRooms.has(groupId)) {
                    groupRooms.set(groupId, new Set());
                }
                groupRooms.get(groupId).add(socket.id);
                
                console.log('User joined group room:', groupId);
            } catch (error) {
                console.error('Join group error:', error);
            }
        });

        // X·ª≠ l√Ω s·ª± ki·ªán th√™m ng∆∞·ªùi kh√°c v√†o nh√≥m
        socket.on('addMemberGroup', async ({ groupId, userId }) => {
            try {
                // Ki·ªÉm tra userId ƒë·ªÉ x√°c nh·∫≠n ng∆∞·ªùi c·∫ßn v√†o nh√≥m l√† ai
                console.log(`User ${userId} ƒëang join group ${groupId}`);
                
                // Cho ph√©p user tham gia ph√≤ng nh√≥m (socket.join)
                socket.join(groupId);

                // Th√™m v√†o danh s√°ch ph√≤ng
                if (!groupRooms.has(groupId)) {
                    groupRooms.set(groupId, new Set());
                }
                groupRooms.get(groupId).add(socket.id);

                const user = await User.getUserById(userId); // L·∫•y th√¥ng tin t√™n/email
                const joinMessage = {
                    messageId: uuidv4(),
                    groupId,
                    senderId: 'system',
                    action: 'join',
                    senderEmail: 'system@chat.app',
                    content: `${user.fullName}`, // Ho·∫∑c `${user.name}` n·∫øu c√≥
                    type: 'system',
                    isDeleted: false,
                    isRecalled: false,
                    isSystem: true,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };

                await Group.addMessage(groupId, joinMessage);

                // ‚úÖ G·ª≠i cho c√°c th√†nh vi√™n trong nh√≥m
                socket.to(groupId).emit('groupMessageJoin', joinMessage);

                console.log(`User ${userId} ƒë√£ join group ${groupId}`);
            } catch (error) {
                console.error('L·ªói khi join group:', error);
            }
        });

        // X·ª≠ l√Ω s·ª± ki·ªán g·ª≠i tin nh·∫Øn nh√≥m
        socket.on('groupMessage', async (data) => {
            try {
                const { groupId, message } = data;
                console.log('New group message:', {
                    groupId,
                    sender: userEmail,
                    messageId: message.messageId
                });

                // G·ª≠i tin nh·∫Øn t·ªõi t·∫•t c·∫£ th√†nh vi√™n trong nh√≥m
                
                io.to(groupId).emit('newGroupMessage', {
                    groupId,
                    message: {
                        ...message,
                        //senderEmail: userEmail
                    }
                });

                // G·ª≠i x√°c nh·∫≠n l·∫°i cho ng∆∞·ªùi g·ª≠i
                console.log('üî• Emit newGroupMessage ƒë·∫øn group:', groupId, 'v·ªõi message:', message);
                socket.emit('groupMessageSent', {
                    success: true,
                    messageId: message.messageId
                });
            } catch (error) {
                console.error('Group message error:', error);
                socket.emit('groupMessageSent', {
                    success: false,
                    error: error.message
                });
            }
        });

        // X·ª≠ l√Ω s·ª± ki·ªán r·ªùi nh√≥m chat
        socket.on('leaveGroup', (data) => {
            try {
                const { groupId } = data;
                console.log('User leaving group:', userEmail, 'groupId:', groupId);
                
                // R·ªùi kh·ªèi ph√≤ng socket c·ªßa nh√≥m
                socket.leave(groupId);
                
                // X√≥a th√¥ng tin ph√≤ng
                if (groupRooms.has(groupId)) {
                    groupRooms.get(groupId).delete(socket.id);
                    if (groupRooms.get(groupId).size === 0) {
                        groupRooms.delete(groupId);
                    }
                }
                
                console.log('User left group room:', groupId);
            } catch (error) {
                console.error('Leave group error:', error);
            }
        });

        // X·ª≠ l√Ω s·ª± ki·ªán r·ªùi nh√≥m web version
        socket.on('leaveGroupWeb', async (data) => {
            console.log('üî• leaveGroupWeb event received!', data);
            try {
                const { groupId, userEmail } = data; // Th√™m userEmail v√†o th√¥ng tin
                console.log('User leaving group web:', userEmail, 'groupId:', groupId);

                const user = await User.getUserByEmail(userEmail);

                const leaveMessage = {
                    messageId: uuidv4(),
                    groupId,
                    senderId: 'system',
                    senderEmail: 'system@chat.app',
                    content: `${user.fullName}`,
                    type: 'system',
                    action: 'leave',
                    isDeleted: false,
                    isRecalled: false,
                    isSystem: true,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                
                await Group.addMessage(groupId, leaveMessage);

                // G·ª≠i th√¥ng b√°o cho c√°c th√†nh vi√™n c√≤n l·∫°i trong nh√≥m
                socket.to(groupId).emit('groupMessageLeave', leaveMessage);
               

                // G·ª≠i th√¥ng b√°o cho c√°c th√†nh vi√™n c√≤n l·∫°i trong nh√≥m
                // socket.to(groupId).emit('groupMessageLeave', {
                //     type: 'system',
                //     content: `${userEmail} ƒë√£ r·ªùi kh·ªèi nh√≥m.`,
                //     groupId,
                //     timestamp: new Date().toISOString(),
                //     isSystem: true
                // });

                 // R·ªùi kh·ªèi ph√≤ng socket c·ªßa nh√≥m
                socket.leave(groupId);

                // X√≥a th√¥ng tin ph√≤ng (x·ª≠ l√Ω nh√≥m)
                if (groupRooms.has(groupId)) {
                    groupRooms.get(groupId).delete(socket.id);
                    if (groupRooms.get(groupId).size === 0) {
                        groupRooms.delete(groupId);
                    }
                }

                console.log('User left group room:', groupId);
            } catch (error) {
                console.error('Leave group error:', error);
            }
        });


        // X·ª≠ l√Ω s·ª± ki·ªán g·ª≠i tin nh·∫Øn m·ªõi
        socket.on('newMessage', async (data) => {
            try {
                const { receiverEmail, message } = data;
                const senderEmail = socket.user.email;

                console.log('New message from:', senderEmail, 'to:', receiverEmail);

                // G·ª≠i tin nh·∫Øn t·ªõi t·∫•t c·∫£ c√°c k·∫øt n·ªëi c·ªßa ng∆∞·ªùi nh·∫≠n
                const receiverSockets = userSockets.get(receiverEmail);
                if (receiverSockets) {
                    receiverSockets.forEach(socketId => {
                        io.to(socketId).emit('newMessage', {
                            ...message,
                            senderEmail
                        });
                    });
                }

                // G·ª≠i x√°c nh·∫≠n l·∫°i cho ng∆∞·ªùi g·ª≠i
                socket.emit('messageSent', {
                    success: true,
                    messageId: message.id
                });
            } catch (error) {
                console.error('New message error:', error);
                socket.emit('messageSent', {
                    success: false,
                    error: error.message
                });
            }
        });

        // X·ª≠ l√Ω s·ª± ki·ªán ƒë√°nh d·∫•u tin nh·∫Øn ƒë√£ ƒë·ªçc
        socket.on('messageRead', async (data) => {
            try {
                const { messageId, senderEmail } = data;
                
                // G·ª≠i th√¥ng b√°o cho t·∫•t c·∫£ c√°c k·∫øt n·ªëi c·ªßa ng∆∞·ªùi g·ª≠i
                const senderSockets = userSockets.get(senderEmail);
                if (senderSockets) {
                    senderSockets.forEach(socketId => {
                        io.to(socketId).emit('messageRead', {
                            messageId
                        });
                    });
                }
            } catch (error) {
                console.error('Message read error:', error);
            }
        });

        // X·ª≠ l√Ω s·ª± ki·ªán b·∫Øt ƒë·∫ßu g√µ tin nh·∫Øn
        socket.on('typingStart', (data) => {
            try {
                const { receiverEmail } = data;
                const senderEmail = socket.user.email;

                console.log('Typing started from:', senderEmail, 'to:', receiverEmail);

                // G·ª≠i th√¥ng b√°o cho t·∫•t c·∫£ c√°c k·∫øt n·ªëi c·ªßa ng∆∞·ªùi nh·∫≠n
                const receiverSockets = userSockets.get(receiverEmail);
                if (receiverSockets) {
                    receiverSockets.forEach(socketId => {
                        io.to(socketId).emit('typingStart', {
                            senderEmail
                        });
                    });
                }
            } catch (error) {
                console.error('Typing start error:', error);
            }
        });

        // X·ª≠ l√Ω s·ª± ki·ªán d·ª´ng g√µ tin nh·∫Øn
        socket.on('typingStop', (data) => {
            try {
                const { receiverEmail } = data;
                const senderEmail = socket.user.email;

                console.log('Typing stopped from:', senderEmail, 'to:', receiverEmail);

                // G·ª≠i th√¥ng b√°o cho t·∫•t c·∫£ c√°c k·∫øt n·ªëi c·ªßa ng∆∞·ªùi nh·∫≠n
                const receiverSockets = userSockets.get(receiverEmail);
                if (receiverSockets) {
                    receiverSockets.forEach(socketId => {
                        io.to(socketId).emit('typingStop', {
                            senderEmail
                        });
                    });
                }
            } catch (error) {
                console.error('Typing stop error:', error);
            }
        });

        // X·ª≠ l√Ω s·ª± ki·ªán g·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n
        socket.on('friendRequestSent', async (data) => {
            try {
                const { receiverEmail } = data;
                const senderEmail = socket.user.email;

                const sender = await User.getUserByEmail(senderEmail);
                if (!sender) return;

                // G·ª≠i th√¥ng b√°o cho t·∫•t c·∫£ c√°c k·∫øt n·ªëi c·ªßa ng∆∞·ªùi nh·∫≠n
                const receiverSockets = userSockets.get(receiverEmail);
                if (receiverSockets) {
                    receiverSockets.forEach(socketId => {
                        io.to(socketId).emit('friendRequestUpdate', {
                            type: 'newRequest',
                            sender: {
                                email: sender.email,
                                fullName: sender.fullName,
                                avatar: sender.avatar
                            }
                        });
                    });
                }
            } catch (error) {
                console.error('Friend request sent error:', error);
            }
        });

        socket.on('withdrawFriendRequest', async (data) => {
            try {
                const { receiverEmail, senderEmail } = data;

                // Th·ª±c hi·ªán logic thu h·ªìi l·ªùi m·ªùi trong DB ·ªü ƒë√¢y

                // G·ª≠i th√¥ng b√°o cho ng∆∞·ªùi nh·∫≠n l·ªùi m·ªùi r·∫±ng l·ªùi m·ªùi ƒë√£ b·ªã thu h·ªìi
                const receiverSockets = userSockets.get(receiverEmail);
                if (receiverSockets) {
                receiverSockets.forEach(socketId => {
                    io.to(socketId).emit('friendRequestWithdrawn', {
                    senderEmail
                    });
                });
                }

                // C√≥ th·ªÉ g·ª≠i x√°c nh·∫≠n cho ng∆∞·ªùi g·ª≠i (n·∫øu c·∫ßn)
                socket.emit('withdrawConfirmed', { success: true });
            } catch (error) {
                console.error('Error withdrawing friend request:', error);
                socket.emit('withdrawConfirmed', { success: false, error: error.message });
            }
        });

        // Th√™m x·ª≠ l√Ω s·ª± ki·ªán khi c√≥ ng∆∞·ªùi ch·∫•p nh·∫≠n l·ªùi m·ªùi k·∫øt b·∫°n
        socket.on('friendRequestAccepted', async (data) => {
            try {
                const { email } = data; // email c·ªßa ng∆∞·ªùi g·ª≠i l·ªùi m·ªùi
                const accepterEmail = socket.user.email;

                // L·∫•y th√¥ng tin c·ªßa c·∫£ hai ng∆∞·ªùi d√πng
                const [accepter, requester] = await Promise.all([
                    User.getUserByEmail(accepterEmail),
                    User.getUserByEmail(email)
                ]);

                if (!accepter || !requester) return;

                // G·ª≠i th√¥ng b√°o c·∫≠p nh·∫≠t danh s√°ch b·∫°n b√® cho ng∆∞·ªùi g·ª≠i l·ªùi m·ªùi
                const requesterSockets = userSockets.get(email);
                if (requesterSockets) {
                    requesterSockets.forEach(socketId => {
                        io.to(socketId).emit('friendListUpdate', {
                            type: 'newFriend',
                            friend: {
                                email: accepter.email,
                                fullName: accepter.fullName,
                                avatar: accepter.avatar,
                                online: true
                            },
                            lastMessage: {
                                message: "B·∫°n ƒë√£ tr·ªü th√†nh b·∫°n b√®",
                                time: new Date(),
                                senderEmail: accepter.email
                            }
                        });
                    });
                }

                // G·ª≠i th√¥ng b√°o c·∫≠p nh·∫≠t danh s√°ch b·∫°n b√® cho ng∆∞·ªùi ch·∫•p nh·∫≠n
                const accepterSockets = userSockets.get(accepterEmail);
                if (accepterSockets) {
                    accepterSockets.forEach(socketId => {
                        io.to(socketId).emit('friendListUpdate', {
                            type: 'newFriend',
                            friend: {
                                email: requester.email,
                                fullName: requester.fullName,
                                avatar: requester.avatar,
                                online: true
                            },
                            lastMessage: {
                                message: "B·∫°n ƒë√£ tr·ªü th√†nh b·∫°n b√®",
                                time: new Date(),
                                senderEmail: accepter.email
                            }
                        });
                    });
                }
            } catch (error) {
                console.error('Friend request accepted error:', error);
            }
        });

        // Th√™m x·ª≠ l√Ω s·ª± ki·ªán khi c√≥ ng∆∞·ªùi h·ªßy k·∫øt b·∫°n
        socket.on('unfriend', async (data) => {
            try {
                const { targetEmail } = data;
                const initiatorEmail = socket.user.email;

                // G·ª≠i th√¥ng b√°o cho ng∆∞·ªùi b·ªã h·ªßy k·∫øt b·∫°n
                const targetSockets = userSockets.get(targetEmail);
                if (targetSockets) {
                    targetSockets.forEach(socketId => {
                        io.to(socketId).emit('friendListUpdate', {
                            type: 'unfriend',
                            email: initiatorEmail
                        });
                    });
                }

                // G·ª≠i th√¥ng b√°o x√°c nh·∫≠n cho ng∆∞·ªùi th·ª±c hi·ªán h·ªßy k·∫øt b·∫°n
                socket.emit('friendListUpdate', {
                    type: 'unfriend',
                    email: targetEmail
                });
            } catch (error) {
                console.error('Unfriend error:', error);
            }
        });

        //Th√™m x·ª≠ l√Ω s·ª± ki·ªán khi ng∆∞·ªùi d√πng online/offline
        socket.on('userStatus', async (data) => {
            try {
                const { status } = data;
                const userEmail = socket.user.email;
                

                // L·∫•y danh s√°ch b·∫°n b√® c·ªßa ng∆∞·ªùi d√πng
                const user = await User.getUserByEmail(userEmail);
                if (!user || !user.friends) return;

                

                //G·ª≠i th√¥ng b√°o tr·∫°ng th√°i cho t·∫•t c·∫£ b·∫°n b√®
                user.friends.forEach(friendEmail => {

                    const friendSockets = userSockets.get(friendEmail);
                    console.log("üì¢ G·ª≠i t·ªõi socket b·∫°n b√®:", friendEmail, friendSockets);
                    if (friendSockets) {
                        friendSockets.forEach(socketId => {
                            io.to(socketId).emit('friendStatusUpdate', {
                                email: userEmail,
                                online: status === 'online'
                            });
                        });
                    }
                    console.log('G·ª≠i tr·∫°ng th√°i t·ªõi:', friendEmail, 'Online:', status === 'online');
                });
                
            } catch (error) {
                console.error('User status update error:', error);
            }
        });

        
        // X·ª≠ l√Ω s·ª± ki·ªán tr·∫°ng th√°i online/offline t·ª´ web
        socket.on('userStatusWeb', async (data) => {
            const { status, email } = data;

            if (!email) return;

            if (status === "offline") {
                // X√≥a socket kh·ªèi danh s√°ch user
                if (userSockets.has(email)) {
                    userSockets.get(email).delete(socket.id);
                    if (userSockets.get(email).size === 0) {
                        userSockets.delete(email);

                        // G·ª≠i tr·∫°ng th√°i offline ƒë·∫øn b·∫°n b√®
                        const user = await User.getUserByEmail(email);
                        if (user?.friends) {
                            user.friends.forEach(friend => {
                                const friendEmail = typeof friend === 'string' ? friend : friend.email;
                                const friendSockets = userSockets.get(friendEmail);
                                if (friendSockets) {
                                    friendSockets.forEach(socketId => {
                                        io.to(socketId).emit('friendStatusUpdateWeb', {
                                            email,
                                            online: false
                                        });
                                    });
                                }
                            });
                        }
                    }
                }

                return; //Kh√¥ng x·ª≠ l√Ω ti·∫øp n·∫øu l√† offline
            }

            // N·∫øu l√† online ‚Äì nh∆∞ c≈©
            if (!userSockets.has(email)) {
                userSockets.set(email, new Set());
            }
            userSockets.get(email).add(socket.id);
            socket.user = { email };

            const user = await User.getUserByEmail(email);
            if (!user || !user.friends) return;

            const onlineFriends = [];
            user.friends.forEach(friend => {
                const friendEmail = typeof friend === 'string' ? friend : friend.email;
                const friendSockets = userSockets.get(friendEmail);
                if (friendSockets) {
                    friendSockets.forEach(socketId => {
                        io.to(socketId).emit('friendStatusUpdateWeb', {
                            email,
                            online: true
                        });
                    });
                    onlineFriends.push(friendEmail);
                }
            });

            // G·ª≠i l·∫°i danh s√°ch b·∫°n b√® online cho user
            socket.emit('initialFriendStatusesWeb', {
                friends: user.friends.map(f => typeof f === 'string' ? f : f.email),
                onlineFriends
            });
        });



        // X·ª≠ l√Ω s·ª± ki·ªán thu h·ªìi tin nh·∫Øn
        socket.on('messageRecalled', async (data) => {
            try {
                const { messageId, receiverEmail, senderEmail } = data;
                console.log('Message recall request:', { messageId, receiverEmail, senderEmail });

                // G·ª≠i th√¥ng b√°o cho t·∫•t c·∫£ c√°c k·∫øt n·ªëi c·ªßa ng∆∞·ªùi nh·∫≠n
                const receiverSockets = userSockets.get(receiverEmail);
                if (receiverSockets) {
                    console.log('Sending recall notification to receiver:', receiverEmail);
                    receiverSockets.forEach(socketId => {
                        io.to(socketId).emit('messageRecalled', {
                            messageId,
                            senderEmail
                        });
                    });
                }

                // G·ª≠i x√°c nh·∫≠n cho ng∆∞·ªùi g·ª≠i
                socket.emit('messageRecallConfirmed', {
                    success: true,
                    messageId
                });
            } catch (error) {
                console.error('Message recall error:', error);
                socket.emit('messageRecallConfirmed', {
                    success: false,
                    error: error.message
                });
            }
        });

        // X·ª≠ l√Ω x√≥a tin nh·∫Øn nh√≥m
        socket.on("recallGroupMessage", (data) => {
            const { groupId, messageId, senderEmail } = data;
            const groupSockets = groupRooms.get(groupId); // tu·ª≥ c√°ch b·∫°n l∆∞u
            if (groupSockets) {
                groupSockets.forEach(socketId => {
                    io.to(socketId).emit("recallGroupMessage", {
                        groupId,
                        messageId,
                        senderEmail,
                    });
                });
            }
        });

        // X·ª≠ l√Ω s·ª± ki·ªán x√≥a tin nh·∫Øn
        socket.on('messageDeleted', async (data) => {
            try {
                const { messageId, receiverEmail } = data;
                console.log('Message delete request:', { messageId, receiverEmail });

                // G·ª≠i th√¥ng b√°o cho t·∫•t c·∫£ c√°c k·∫øt n·ªëi c·ªßa ng∆∞·ªùi nh·∫≠n
                const receiverSockets = userSockets.get(receiverEmail);
                if (receiverSockets) {
                    console.log('Sending delete notification to receiver:', receiverEmail);
                    receiverSockets.forEach(socketId => {
                        io.to(socketId).emit('messageDeleted', {
                            messageId
                        });
                    });
                }

                // G·ª≠i x√°c nh·∫≠n cho ng∆∞·ªùi g·ª≠i
                socket.emit('messageDeleteConfirmed', {
                    success: true,
                    messageId
                });
            } catch (error) {
                console.error('Message delete error:', error);
                socket.emit('messageDeleteConfirmed', {
                    success: false,
                    error: error.message
                });
            }
        });


        // X·ª≠ l√Ω s·ª± ki·ªán reaction tin nh·∫Øn
        socket.on('messageReaction', async (data) => {
            try {
                const { messageId, reaction, receiverEmail } = data;
                const senderEmail = socket.user.email;
                console.log('Message reaction:', { messageId, reaction, senderEmail, receiverEmail });

                // G·ª≠i th√¥ng b√°o cho t·∫•t c·∫£ c√°c k·∫øt n·ªëi c·ªßa ng∆∞·ªùi nh·∫≠n
                const receiverSockets = userSockets.get(receiverEmail);
                if (receiverSockets) {
                    console.log('Sending reaction notification to receiver:', receiverEmail);
                    receiverSockets.forEach(socketId => {
                        io.to(socketId).emit('messageReaction', {
                            messageId,
                            reaction,
                            senderEmail
                        });
                    });
                }

                // G·ª≠i x√°c nh·∫≠n cho ng∆∞·ªùi g·ª≠i reaction
                socket.emit('messageReactionConfirmed', {
                    success: true,
                    messageId,
                    reaction
                });
            } catch (error) {
                console.error('Message reaction error:', error);
                socket.emit('messageReactionConfirmed', {
                    success: false,
                    error: error.message
                });
            }
        });

        socket.on("groupMessageReaction", async (data) => {
            try {
                const { messageId, reaction, groupId } = data;
                const senderEmail = socket.user.email;

                console.log("üì® Group message reaction received:", { groupId, messageId, reaction });

                // G·ª≠i cho t·∫•t c·∫£ trong nh√≥m (tr·ª´ ng∆∞·ªùi g·ª≠i)
                socket.to(groupId).emit("messageReaction", {
                    messageId,
                    reaction,
                    senderEmail
                });

                socket.emit("messageReactionConfirmed", {
                    success: true,
                    messageId,
                    reaction
                });
            } catch (error) {
                console.error("Group message reaction error:", error);
                socket.emit("messageReactionConfirmed", {
                    success: false,
                    error: error.message
                });
            }
        });

        // socket.on("register", (userId) => {
        //     onlineUsers[userId] = socket.id;
        //     console.log(`User ${userId} connected with socket ${socket.id}`);
        // });

        // socket.on("disconnect", () => {
        //     // X√≥a user kh·ªèi onlineUsers khi disconnect
        //     for (const [userId, socketId] of Object.entries(onlineUsers)) {
        //     if (socketId === socket.id) {
        //         delete onlineUsers[userId];
        //         break;
        //     }
        //     }
        // });

        socket.on("call-user", ({ fromUserId, toUserId }) => {
            const toSocketId = onlineUsers[toUserId];
            if (toSocketId) {
                console.log(`üìû ${fromUserId} ƒëang g·ªçi ${toUserId}`);
                io.to(toSocketId).emit("incoming-call", { fromUserId });
            } else {
                console.log(`‚ùå Kh√¥ng t√¨m th·∫•y ${toUserId} online`);
            }
        });

        socket.on("call-declined", ({ fromUserId, toUserId }) => {
            const toSocketId = onlineUsers[fromUserId]; // A l√† ng∆∞·ªùi g·ªçi
            if (toSocketId) {
                io.to(toSocketId).emit("call-declined", { fromUserId, toUserId });
            }
            console.log("üì® call-declined t·ª´", toUserId, "v·ªÅ", fromUserId);
            console.log("üì¶ Socket c·ªßa ng∆∞·ªùi g·ªçi (fromUserId):", toSocketId);
        });

        socket.on("call-accepted", ({ fromUserId, toUserId }) => {
            const toSocketId = onlineUsers[fromUserId];
            if (toSocketId) {
                io.to(toSocketId).emit("call-accepted", { fromUserId, toUserId });
            }
        });

        socket.on("call-cancelled", ({ fromUserId, toUserId }) => {
            const toSocketId = onlineUsers[toUserId];

            if (toSocketId) {
                io.to(toSocketId).emit("call-cancelled", { fromUserId, toUserId });
            } else {
                console.log(`‚ùå Kh√¥ng t√¨m th·∫•y ${toUserId} online ƒë·ªÉ g·ª≠i th√¥ng b√°o h·ªßy`);
            }
        });

        socket.on("call-ended", ({ roomId }) => {
            console.log("üì© G·ªçi call-ended v·ªõi roomId:", roomId);
            console.log("üßë socket.userId l√†:", socket.userId);

            const [user1, user2] = roomId.split("_");
            const currentUser = socket.userId;
            const otherUser = currentUser === user1 ? user2 : user1;

            const toSocketId = onlineUsers[otherUser]; 
            if (toSocketId) {
                io.to(toSocketId).emit("call-ended", { roomId });
                console.log(`üìû Cu·ªôc g·ªçi k·∫øt th√∫c - g·ª≠i ƒë·∫øn ${otherUser}`);
            } else {
                console.log(`‚ùå Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi c√≤n l·∫°i (${otherUser}) online`);
            }
        });

        socket.on('disconnect', async () => {
            const userEmail = socket.user?.email;
            console.log('Client disconnected:', userEmail);

            if (userEmail && userSockets.has(userEmail)) {
                userSockets.get(userEmail).delete(socket.id);

                if (userSockets.get(userEmail).size === 0) {
                    userSockets.delete(userEmail);

                    // G·ª≠i th√¥ng b√°o offline ƒë·∫øn b·∫°n b√®
                    try {
                        const user = await User.getUserByEmail(userEmail);
                        if (user?.friends) {
                            user.friends.forEach(friend => {
                                const friendEmail = typeof friend === 'string' ? friend : friend.email;
                                const friendSockets = userSockets.get(friendEmail);
                                if (friendSockets) {
                                    friendSockets.forEach(socketId => {
                                        io.to(socketId).emit('friendStatusUpdateWeb', {
                                            email: userEmail,
                                            online: false
                                        });
                                    });
                                }
                            });
                        }
                    } catch (error) {
                        console.error('Error notifying friends of disconnect:', error);
                    }
                }
            }

            // ‚úÖ X√≥a socket kh·ªèi t·∫•t c·∫£ c√°c ph√≤ng nh√≥m
            groupRooms.forEach((sockets, groupId) => {
                if (sockets.has(socket.id)) {
                    sockets.delete(socket.id);
                    if (sockets.size === 0) {
                        groupRooms.delete(groupId);
                    }
                }
            });
        });

    });

    return io;
};

const getIO = () => {
    if (!io) {
        throw new Error('Socket.IO not initialized');
    }
    return io;
};

module.exports = {
    initializeSocket,
    getIO
}; 